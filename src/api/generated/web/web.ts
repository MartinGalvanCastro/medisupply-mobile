/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * BFF Service
 * Backend For Frontend service aggregating microservices
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BatchProductsResponse,
  BodyCreateProductsFromCsvBffWebProductsBatchPost,
  GetInventoriesBffWebInventoriesGetParams,
  GetProductsBffWebProductsGetParams,
  GetProvidersBffWebProvidersGetParams,
  GetSalesPlansBffWebSalesPlansGetParams,
  GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  GetSellersBffWebSellersGet200,
  GetSellersBffWebSellersGetParams,
  GetWarehousesBffWebWarehousesGetParams,
  HTTPValidationError,
  InventoryCreateRequest,
  InventoryCreateResponse,
  NotFoundErrorResponse,
  PaginatedInventoriesResponse,
  PaginatedProductsResponse,
  PaginatedProvidersResponse,
  PaginatedSalesPlansResponse,
  PaginatedWarehousesResponse,
  ProductCreate,
  ProviderCreate,
  ProviderCreateResponse,
  SalesPlanCreate,
  SalesPlanCreateResponse,
  SellerCreate,
  SellerCreateResponse,
  ValidationErrorResponse,
  WarehouseCreate,
  WarehouseCreateResponse,
} from ".././models";

import { customInstance } from "../../client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Create a new provider in the catalog microservice.

Args:
    provider: Provider data to create
    catalog: Catalog port for service communication

Returns:
    Created provider id and success message
 * @summary Create Provider
 */
export const createProviderBffWebProviderPost = (
  providerCreate: ProviderCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderCreateResponse>(
    {
      url: `/bff/web/provider`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: providerCreate,
      signal,
    },
    options,
  );
};

export const getCreateProviderBffWebProviderPostMutationOptions = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProviderBffWebProviderPost>>,
    TError,
    { data: ProviderCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProviderBffWebProviderPost>>,
  TError,
  { data: ProviderCreate },
  TContext
> => {
  const mutationKey = ["createProviderBffWebProviderPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProviderBffWebProviderPost>>,
    { data: ProviderCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createProviderBffWebProviderPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProviderBffWebProviderPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProviderBffWebProviderPost>>
>;
export type CreateProviderBffWebProviderPostMutationBody = ProviderCreate;
export type CreateProviderBffWebProviderPostMutationError =
  void | HTTPValidationError;

/**
 * @summary Create Provider
 */
export const useCreateProviderBffWebProviderPost = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProviderBffWebProviderPost>>,
      TError,
      { data: ProviderCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProviderBffWebProviderPost>>,
  TError,
  { data: ProviderCreate },
  TContext
> => {
  const mutationOptions =
    getCreateProviderBffWebProviderPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve providers from the catalog microservice.

Args:
    limit: Maximum number of providers to return (1-100)
    offset: Number of providers to skip
    catalog: Catalog port for service communication

Returns:
    Paginated list of providers
 * @summary Get Providers
 */
export const getProvidersBffWebProvidersGet = (
  params?: GetProvidersBffWebProvidersGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedProvidersResponse>(
    { url: `/bff/web/providers`, method: "GET", params, signal },
    options,
  );
};

export const getGetProvidersBffWebProvidersGetQueryKey = (
  params?: GetProvidersBffWebProvidersGetParams,
) => {
  return [`/bff/web/providers`, ...(params ? [params] : [])] as const;
};

export const getGetProvidersBffWebProvidersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetProvidersBffWebProvidersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProvidersBffWebProvidersGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>
  > = ({ signal }) =>
    getProvidersBffWebProvidersGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProvidersBffWebProvidersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>
>;
export type GetProvidersBffWebProvidersGetQueryError =
  void | HTTPValidationError;

export function useGetProvidersBffWebProvidersGet<
  TData = Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
  TError = void | HTTPValidationError,
>(
  params: undefined | GetProvidersBffWebProvidersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
          TError,
          Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProvidersBffWebProvidersGet<
  TData = Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetProvidersBffWebProvidersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
          TError,
          Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProvidersBffWebProvidersGet<
  TData = Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetProvidersBffWebProvidersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Providers
 */

export function useGetProvidersBffWebProvidersGet<
  TData = Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetProvidersBffWebProvidersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvidersBffWebProvidersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProvidersBffWebProvidersGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a single product.

This endpoint accepts a single product and sends it as a batch of size 1
to the catalog microservice.

Args:
    product: Product data to create
    catalog: Catalog port for service communication

Returns:
    Response with the created product
 * @summary Create Product
 */
export const createProductBffWebProductsPost = (
  productCreate: ProductCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BatchProductsResponse>(
    {
      url: `/bff/web/products`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: productCreate,
      signal,
    },
    options,
  );
};

export const getCreateProductBffWebProductsPostMutationOptions = <
  TError = void | NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProductBffWebProductsPost>>,
    TError,
    { data: ProductCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProductBffWebProductsPost>>,
  TError,
  { data: ProductCreate },
  TContext
> => {
  const mutationKey = ["createProductBffWebProductsPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProductBffWebProductsPost>>,
    { data: ProductCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createProductBffWebProductsPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductBffWebProductsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProductBffWebProductsPost>>
>;
export type CreateProductBffWebProductsPostMutationBody = ProductCreate;
export type CreateProductBffWebProductsPostMutationError =
  | void
  | NotFoundErrorResponse
  | ValidationErrorResponse;

/**
 * @summary Create Product
 */
export const useCreateProductBffWebProductsPost = <
  TError = void | NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProductBffWebProductsPost>>,
      TError,
      { data: ProductCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProductBffWebProductsPost>>,
  TError,
  { data: ProductCreate },
  TContext
> => {
  const mutationOptions =
    getCreateProductBffWebProductsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve products from the catalog microservice.

Args:
    limit: Maximum number of products to return (1-100)
    offset: Number of products to skip
    catalog: Catalog port for service communication

Returns:
    Paginated list of products
 * @summary Get Products
 */
export const getProductsBffWebProductsGet = (
  params?: GetProductsBffWebProductsGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedProductsResponse>(
    { url: `/bff/web/products`, method: "GET", params, signal },
    options,
  );
};

export const getGetProductsBffWebProductsGetQueryKey = (
  params?: GetProductsBffWebProductsGetParams,
) => {
  return [`/bff/web/products`, ...(params ? [params] : [])] as const;
};

export const getGetProductsBffWebProductsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
  TError = void | ValidationErrorResponse,
>(
  params?: GetProductsBffWebProductsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsBffWebProductsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsBffWebProductsGet>>
  > = ({ signal }) =>
    getProductsBffWebProductsGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProductsBffWebProductsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsBffWebProductsGet>>
>;
export type GetProductsBffWebProductsGetQueryError =
  void | ValidationErrorResponse;

export function useGetProductsBffWebProductsGet<
  TData = Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
  TError = void | ValidationErrorResponse,
>(
  params: undefined | GetProductsBffWebProductsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
          TError,
          Awaited<ReturnType<typeof getProductsBffWebProductsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsBffWebProductsGet<
  TData = Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
  TError = void | ValidationErrorResponse,
>(
  params?: GetProductsBffWebProductsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
          TError,
          Awaited<ReturnType<typeof getProductsBffWebProductsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProductsBffWebProductsGet<
  TData = Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
  TError = void | ValidationErrorResponse,
>(
  params?: GetProductsBffWebProductsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Products
 */

export function useGetProductsBffWebProductsGet<
  TData = Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
  TError = void | ValidationErrorResponse,
>(
  params?: GetProductsBffWebProductsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsBffWebProductsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProductsBffWebProductsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create multiple products from a CSV file.

The CSV file must have the following columns:
- provider_id (UUID)
- name (string)
- category (medicamentos_especiales, insumos_quirurgicos, reactivos_diagnosticos, equipos_biomedicos, otros)
- sku (string - unique identifier)
- price (decimal)

All products are created in a single transaction in the catalog service.
If any product fails validation or creation, all products are rolled back.

Args:
    file: CSV file with product data
    catalog: Catalog port for service communication

Returns:
    Response with all created products
 * @summary Create Products From Csv
 */
export const createProductsFromCsvBffWebProductsBatchPost = (
  bodyCreateProductsFromCsvBffWebProductsBatchPost: BodyCreateProductsFromCsvBffWebProductsBatchPost,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(
    `file`,
    bodyCreateProductsFromCsvBffWebProductsBatchPost.file,
  );

  return customInstance<BatchProductsResponse>(
    {
      url: `/bff/web/products/batch`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options,
  );
};

export const getCreateProductsFromCsvBffWebProductsBatchPostMutationOptions = <
  TError = void | NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>,
    TError,
    { data: BodyCreateProductsFromCsvBffWebProductsBatchPost },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>,
  TError,
  { data: BodyCreateProductsFromCsvBffWebProductsBatchPost },
  TContext
> => {
  const mutationKey = ["createProductsFromCsvBffWebProductsBatchPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>,
    { data: BodyCreateProductsFromCsvBffWebProductsBatchPost }
  > = (props) => {
    const { data } = props ?? {};

    return createProductsFromCsvBffWebProductsBatchPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductsFromCsvBffWebProductsBatchPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>
  >;
export type CreateProductsFromCsvBffWebProductsBatchPostMutationBody =
  BodyCreateProductsFromCsvBffWebProductsBatchPost;
export type CreateProductsFromCsvBffWebProductsBatchPostMutationError =
  | void
  | NotFoundErrorResponse
  | ValidationErrorResponse;

/**
 * @summary Create Products From Csv
 */
export const useCreateProductsFromCsvBffWebProductsBatchPost = <
  TError = void | NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>,
      TError,
      { data: BodyCreateProductsFromCsvBffWebProductsBatchPost },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProductsFromCsvBffWebProductsBatchPost>>,
  TError,
  { data: BodyCreateProductsFromCsvBffWebProductsBatchPost },
  TContext
> => {
  const mutationOptions =
    getCreateProductsFromCsvBffWebProductsBatchPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new warehouse in the inventory microservice.

Args:
    warehouse: Warehouse data to create
    inventory: Inventory port for service communication

Returns:
    Created warehouse id and success message
 * @summary Create Warehouse
 */
export const createWarehouseBffWebWarehousePost = (
  warehouseCreate: WarehouseCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WarehouseCreateResponse>(
    {
      url: `/bff/web/warehouse`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: warehouseCreate,
      signal,
    },
    options,
  );
};

export const getCreateWarehouseBffWebWarehousePostMutationOptions = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>,
    TError,
    { data: WarehouseCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>,
  TError,
  { data: WarehouseCreate },
  TContext
> => {
  const mutationKey = ["createWarehouseBffWebWarehousePost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>,
    { data: WarehouseCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createWarehouseBffWebWarehousePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateWarehouseBffWebWarehousePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>
>;
export type CreateWarehouseBffWebWarehousePostMutationBody = WarehouseCreate;
export type CreateWarehouseBffWebWarehousePostMutationError =
  void | HTTPValidationError;

/**
 * @summary Create Warehouse
 */
export const useCreateWarehouseBffWebWarehousePost = <
  TError = void | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>,
      TError,
      { data: WarehouseCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createWarehouseBffWebWarehousePost>>,
  TError,
  { data: WarehouseCreate },
  TContext
> => {
  const mutationOptions =
    getCreateWarehouseBffWebWarehousePostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve warehouses from the inventory microservice.

Args:
    limit: Maximum number of warehouses to return (1-100)
    offset: Number of warehouses to skip
    inventory: Inventory port for service communication

Returns:
    Paginated list of warehouses
 * @summary Get Warehouses
 */
export const getWarehousesBffWebWarehousesGet = (
  params?: GetWarehousesBffWebWarehousesGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedWarehousesResponse>(
    { url: `/bff/web/warehouses`, method: "GET", params, signal },
    options,
  );
};

export const getGetWarehousesBffWebWarehousesGetQueryKey = (
  params?: GetWarehousesBffWebWarehousesGetParams,
) => {
  return [`/bff/web/warehouses`, ...(params ? [params] : [])] as const;
};

export const getGetWarehousesBffWebWarehousesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetWarehousesBffWebWarehousesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetWarehousesBffWebWarehousesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>
  > = ({ signal }) =>
    getWarehousesBffWebWarehousesGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWarehousesBffWebWarehousesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>
>;
export type GetWarehousesBffWebWarehousesGetQueryError =
  void | HTTPValidationError;

export function useGetWarehousesBffWebWarehousesGet<
  TData = Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
  TError = void | HTTPValidationError,
>(
  params: undefined | GetWarehousesBffWebWarehousesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
          TError,
          Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWarehousesBffWebWarehousesGet<
  TData = Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetWarehousesBffWebWarehousesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
          TError,
          Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWarehousesBffWebWarehousesGet<
  TData = Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetWarehousesBffWebWarehousesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Warehouses
 */

export function useGetWarehousesBffWebWarehousesGet<
  TData = Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetWarehousesBffWebWarehousesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWarehousesBffWebWarehousesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetWarehousesBffWebWarehousesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new inventory entry.

This endpoint orchestrates between catalog and inventory microservices:
1. Fetches product data from catalog service
2. Validates product exists
3. Creates inventory with denormalized product data

Args:
    request_data: Inventory creation data from client (JSON body) - does NOT include denormalized fields
    catalog: Catalog port for service communication
    inventory: Inventory port for service communication

Returns:
    Created inventory id and success message

Raises:
    HTTPException: 404 if product not found
 * @summary Create Inventory
 */
export const createInventoryBffWebInventoryPost = (
  inventoryCreateRequest: InventoryCreateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<InventoryCreateResponse>(
    {
      url: `/bff/web/inventory`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inventoryCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateInventoryBffWebInventoryPostMutationOptions = <
  TError = NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>,
    TError,
    { data: InventoryCreateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>,
  TError,
  { data: InventoryCreateRequest },
  TContext
> => {
  const mutationKey = ["createInventoryBffWebInventoryPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>,
    { data: InventoryCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createInventoryBffWebInventoryPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateInventoryBffWebInventoryPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>
>;
export type CreateInventoryBffWebInventoryPostMutationBody =
  InventoryCreateRequest;
export type CreateInventoryBffWebInventoryPostMutationError =
  | NotFoundErrorResponse
  | ValidationErrorResponse;

/**
 * @summary Create Inventory
 */
export const useCreateInventoryBffWebInventoryPost = <
  TError = NotFoundErrorResponse | ValidationErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>,
      TError,
      { data: InventoryCreateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createInventoryBffWebInventoryPost>>,
  TError,
  { data: InventoryCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateInventoryBffWebInventoryPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieve inventories from the inventory microservice with optional filters.

Args:
    limit: Maximum number of inventories to return (1-100)
    offset: Number of inventories to skip
    sku: Optional product SKU filter
    warehouse_id: Optional warehouse ID filter
    inventory: Inventory port for service communication

Returns:
    Paginated list of inventories (with denormalized product and warehouse data)
 * @summary Get Inventories
 */
export const getInventoriesBffWebInventoriesGet = (
  params?: GetInventoriesBffWebInventoriesGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedInventoriesResponse>(
    { url: `/bff/web/inventories`, method: "GET", params, signal },
    options,
  );
};

export const getGetInventoriesBffWebInventoriesGetQueryKey = (
  params?: GetInventoriesBffWebInventoriesGetParams,
) => {
  return [`/bff/web/inventories`, ...(params ? [params] : [])] as const;
};

export const getGetInventoriesBffWebInventoriesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
  TError = ValidationErrorResponse,
>(
  params?: GetInventoriesBffWebInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInventoriesBffWebInventoriesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>
  > = ({ signal }) =>
    getInventoriesBffWebInventoriesGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInventoriesBffWebInventoriesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>
>;
export type GetInventoriesBffWebInventoriesGetQueryError =
  ValidationErrorResponse;

export function useGetInventoriesBffWebInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
  TError = ValidationErrorResponse,
>(
  params: undefined | GetInventoriesBffWebInventoriesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoriesBffWebInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
  TError = ValidationErrorResponse,
>(
  params?: GetInventoriesBffWebInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoriesBffWebInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
  TError = ValidationErrorResponse,
>(
  params?: GetInventoriesBffWebInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Inventories
 */

export function useGetInventoriesBffWebInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
  TError = ValidationErrorResponse,
>(
  params?: GetInventoriesBffWebInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffWebInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetInventoriesBffWebInventoriesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new seller.

Args:
    seller: Seller data to create
    seller_port: Seller port for service communication

Returns:
    Created seller id and success message
 * @summary Create Seller
 */
export const createSellerBffWebSellersPost = (
  sellerCreate: SellerCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SellerCreateResponse>(
    {
      url: `/bff/web/sellers`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: sellerCreate,
      signal,
    },
    options,
  );
};

export const getCreateSellerBffWebSellersPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSellerBffWebSellersPost>>,
    TError,
    { data: SellerCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSellerBffWebSellersPost>>,
  TError,
  { data: SellerCreate },
  TContext
> => {
  const mutationKey = ["createSellerBffWebSellersPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSellerBffWebSellersPost>>,
    { data: SellerCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createSellerBffWebSellersPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSellerBffWebSellersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSellerBffWebSellersPost>>
>;
export type CreateSellerBffWebSellersPostMutationBody = SellerCreate;
export type CreateSellerBffWebSellersPostMutationError = HTTPValidationError;

/**
 * @summary Create Seller
 */
export const useCreateSellerBffWebSellersPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSellerBffWebSellersPost>>,
      TError,
      { data: SellerCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSellerBffWebSellersPost>>,
  TError,
  { data: SellerCreate },
  TContext
> => {
  const mutationOptions =
    getCreateSellerBffWebSellersPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get sellers with pagination.

Args:
    limit: Maximum number of sellers to return (1-100)
    offset: Number of sellers to skip
    seller_port: Seller port for service communication

Returns:
    Paginated list of sellers
 * @summary Get Sellers
 */
export const getSellersBffWebSellersGet = (
  params?: GetSellersBffWebSellersGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSellersBffWebSellersGet200>(
    { url: `/bff/web/sellers`, method: "GET", params, signal },
    options,
  );
};

export const getGetSellersBffWebSellersGetQueryKey = (
  params?: GetSellersBffWebSellersGetParams,
) => {
  return [`/bff/web/sellers`, ...(params ? [params] : [])] as const;
};

export const getGetSellersBffWebSellersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSellersBffWebSellersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSellersBffWebSellersGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSellersBffWebSellersGet>>
  > = ({ signal }) =>
    getSellersBffWebSellersGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSellersBffWebSellersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSellersBffWebSellersGet>>
>;
export type GetSellersBffWebSellersGetQueryError = HTTPValidationError;

export function useGetSellersBffWebSellersGet<
  TData = Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetSellersBffWebSellersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
          TError,
          Awaited<ReturnType<typeof getSellersBffWebSellersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSellersBffWebSellersGet<
  TData = Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSellersBffWebSellersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
          TError,
          Awaited<ReturnType<typeof getSellersBffWebSellersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSellersBffWebSellersGet<
  TData = Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSellersBffWebSellersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Sellers
 */

export function useGetSellersBffWebSellersGet<
  TData = Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSellersBffWebSellersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSellersBffWebSellersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSellersBffWebSellersGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get sales plans for a specific seller with pagination.

Args:
    seller_id: UUID of the seller
    limit: Maximum number of sales plans to return (1-100)
    offset: Number of sales plans to skip
    seller_port: Seller port for service communication

Returns:
    Paginated list of sales plans for the seller
 * @summary Get Seller Sales Plans
 */
export const getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet = (
  sellerId: string,
  params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedSalesPlansResponse>(
    {
      url: `/bff/web/sellers/${sellerId}/sales-plans`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryKey =
  (
    sellerId?: string,
    params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  ) => {
    return [
      `/bff/web/sellers/${sellerId}/sales-plans`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
    >,
    TError = HTTPValidationError,
  >(
    sellerId: string,
    params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryKey(
        sellerId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
      >
    > = ({ signal }) =>
      getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet(
        sellerId,
        params,
        requestOptions,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!sellerId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
    >
  >;
export type GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryError =
  HTTPValidationError;

export function useGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGet<
  TData = Awaited<
    ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
  >,
  TError = HTTPValidationError,
>(
  sellerId: string,
  params:
    | undefined
    | GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGet<
  TData = Awaited<
    ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
  >,
  TError = HTTPValidationError,
>(
  sellerId: string,
  params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGet<
  TData = Awaited<
    ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
  >,
  TError = HTTPValidationError,
>(
  sellerId: string,
  params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Seller Sales Plans
 */

export function useGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGet<
  TData = Awaited<
    ReturnType<typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet>
  >,
  TError = HTTPValidationError,
>(
  sellerId: string,
  params?: GetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSellerSalesPlansBffWebSellersSellerIdSalesPlansGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetQueryOptions(
      sellerId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new sales plan.

Args:
    sales_plan: Sales plan data to create
    seller_port: Seller port for service communication

Returns:
    Created sales plan id and success message
 * @summary Create Sales Plan
 */
export const createSalesPlanBffWebSalesPlansPost = (
  salesPlanCreate: SalesPlanCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SalesPlanCreateResponse>(
    {
      url: `/bff/web/sales-plans`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: salesPlanCreate,
      signal,
    },
    options,
  );
};

export const getCreateSalesPlanBffWebSalesPlansPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>,
    TError,
    { data: SalesPlanCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>,
  TError,
  { data: SalesPlanCreate },
  TContext
> => {
  const mutationKey = ["createSalesPlanBffWebSalesPlansPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>,
    { data: SalesPlanCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createSalesPlanBffWebSalesPlansPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSalesPlanBffWebSalesPlansPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>
>;
export type CreateSalesPlanBffWebSalesPlansPostMutationBody = SalesPlanCreate;
export type CreateSalesPlanBffWebSalesPlansPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Sales Plan
 */
export const useCreateSalesPlanBffWebSalesPlansPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>,
      TError,
      { data: SalesPlanCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSalesPlanBffWebSalesPlansPost>>,
  TError,
  { data: SalesPlanCreate },
  TContext
> => {
  const mutationOptions =
    getCreateSalesPlanBffWebSalesPlansPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get sales plans with pagination.

Args:
    limit: Maximum number of sales plans to return (1-100)
    offset: Number of sales plans to skip
    seller_port: Seller port for service communication

Returns:
    Paginated list of sales plans
 * @summary Get Sales Plans
 */
export const getSalesPlansBffWebSalesPlansGet = (
  params?: GetSalesPlansBffWebSalesPlansGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedSalesPlansResponse>(
    { url: `/bff/web/sales-plans`, method: "GET", params, signal },
    options,
  );
};

export const getGetSalesPlansBffWebSalesPlansGetQueryKey = (
  params?: GetSalesPlansBffWebSalesPlansGetParams,
) => {
  return [`/bff/web/sales-plans`, ...(params ? [params] : [])] as const;
};

export const getGetSalesPlansBffWebSalesPlansGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesPlansBffWebSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSalesPlansBffWebSalesPlansGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>
  > = ({ signal }) =>
    getSalesPlansBffWebSalesPlansGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSalesPlansBffWebSalesPlansGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>
>;
export type GetSalesPlansBffWebSalesPlansGetQueryError = HTTPValidationError;

export function useGetSalesPlansBffWebSalesPlansGet<
  TData = Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetSalesPlansBffWebSalesPlansGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesPlansBffWebSalesPlansGet<
  TData = Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesPlansBffWebSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
          TError,
          Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSalesPlansBffWebSalesPlansGet<
  TData = Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesPlansBffWebSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Sales Plans
 */

export function useGetSalesPlansBffWebSalesPlansGet<
  TData = Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSalesPlansBffWebSalesPlansGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSalesPlansBffWebSalesPlansGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSalesPlansBffWebSalesPlansGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
