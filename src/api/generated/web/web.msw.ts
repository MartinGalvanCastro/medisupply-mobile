/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * BFF Service
 * Backend For Frontend service aggregating microservices
 * OpenAPI spec version: 1.0.0
 */
import { faker } from "@faker-js/faker";

import { HttpResponse, delay, http } from "msw";
import type { RequestHandlerOptions } from "msw";

import { ReportStatus, ReportType } from ".././models";
import type {
  BatchProductsResponse,
  GetSellersBffWebSellersGet200,
  InventoryCreateResponse,
  PaginatedInventoriesResponse,
  PaginatedProductsResponse,
  PaginatedProvidersResponse,
  PaginatedReportsResponse,
  PaginatedSalesPlansResponse,
  PaginatedWarehousesResponse,
  ProviderCreateResponse,
  ReportCreateResponse,
  ReportResponse,
  SalesPlanCreateResponse,
  SellerCreateResponse,
  WarehouseCreateResponse,
} from ".././models";

export const getCreateProviderBffWebProviderPostResponseMock = (
  overrideResponse: Partial<ProviderCreateResponse> = {},
): ProviderCreateResponse => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  message: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetProvidersBffWebProvidersGetResponseMock = (
  overrideResponse: Partial<PaginatedProvidersResponse> = {},
): PaginatedProvidersResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    nit: faker.string.alpha({ length: { min: 10, max: 20 } }),
    contact_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    email: faker.string.alpha({ length: { min: 10, max: 20 } }),
    phone: faker.string.alpha({ length: { min: 10, max: 20 } }),
    address: faker.string.alpha({ length: { min: 10, max: 20 } }),
    country: faker.string.alpha({ length: { min: 10, max: 20 } }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCreateProductBffWebProductsPostResponseMock = (
  overrideResponse: Partial<BatchProductsResponse> = {},
): BatchProductsResponse => ({
  created: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    provider_id: faker.string.uuid(),
    provider_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    category: faker.string.alpha({ length: { min: 10, max: 20 } }),
    sku: faker.string.alpha({ length: { min: 10, max: 20 } }),
    price: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  count: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getGetProductsBffWebProductsGetResponseMock = (
  overrideResponse: Partial<PaginatedProductsResponse> = {},
): PaginatedProductsResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    provider_id: faker.string.uuid(),
    provider_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    category: faker.string.alpha({ length: { min: 10, max: 20 } }),
    sku: faker.string.alpha({ length: { min: 10, max: 20 } }),
    price: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCreateProductsFromCsvBffWebProductsBatchPostResponseMock = (
  overrideResponse: Partial<BatchProductsResponse> = {},
): BatchProductsResponse => ({
  created: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    provider_id: faker.string.uuid(),
    provider_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    category: faker.string.alpha({ length: { min: 10, max: 20 } }),
    sku: faker.string.alpha({ length: { min: 10, max: 20 } }),
    price: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  count: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getCreateWarehouseBffWebWarehousePostResponseMock = (
  overrideResponse: Partial<WarehouseCreateResponse> = {},
): WarehouseCreateResponse => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  message: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetWarehousesBffWebWarehousesGetResponseMock = (
  overrideResponse: Partial<PaginatedWarehousesResponse> = {},
): PaginatedWarehousesResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    country: faker.string.alpha({ length: { min: 10, max: 20 } }),
    city: faker.string.alpha({ length: { min: 10, max: 20 } }),
    address: faker.string.alpha({ length: { min: 10, max: 20 } }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCreateInventoryBffWebInventoryPostResponseMock = (
  overrideResponse: Partial<InventoryCreateResponse> = {},
): InventoryCreateResponse => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  message: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetInventoriesBffWebInventoriesGetResponseMock = (
  overrideResponse: Partial<PaginatedInventoriesResponse> = {},
): PaginatedInventoriesResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    product_id: faker.string.uuid(),
    warehouse_id: faker.string.uuid(),
    total_quantity: faker.number.int({ min: undefined, max: undefined }),
    reserved_quantity: faker.number.int({ min: undefined, max: undefined }),
    batch_number: faker.string.alpha({ length: { min: 10, max: 20 } }),
    expiration_date: `${faker.date.past().toISOString().split(".")[0]}Z`,
    product_sku: faker.string.alpha({ length: { min: 10, max: 20 } }),
    product_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    product_price: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    warehouse_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    warehouse_city: faker.string.alpha({ length: { min: 10, max: 20 } }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCreateSellerBffWebSellersPostResponseMock = (
  overrideResponse: Partial<SellerCreateResponse> = {},
): SellerCreateResponse => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  message: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetSellersBffWebSellersGetResponseMock =
  (): GetSellersBffWebSellersGet200 =>
    faker.helpers.arrayElement([
      {
        items: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          id: faker.string.uuid(),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          email: faker.string.alpha({ length: { min: 10, max: 20 } }),
          phone: faker.string.alpha({ length: { min: 10, max: 20 } }),
          city: faker.string.alpha({ length: { min: 10, max: 20 } }),
          country: faker.string.alpha({ length: { min: 10, max: 20 } }),
          created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
          updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
        })),
        total: faker.number.int({ min: undefined, max: undefined }),
        page: faker.number.int({ min: undefined, max: undefined }),
        size: faker.number.int({ min: undefined, max: undefined }),
        has_next: faker.datatype.boolean(),
        has_previous: faker.datatype.boolean(),
      },
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.uuid(),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
        phone: faker.string.alpha({ length: { min: 10, max: 20 } }),
        city: faker.string.alpha({ length: { min: 10, max: 20 } }),
        country: faker.string.alpha({ length: { min: 10, max: 20 } }),
        created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
        updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
      })),
    ]);

export const getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetResponseMock =
  (
    overrideResponse: Partial<PaginatedSalesPlansResponse> = {},
  ): PaginatedSalesPlansResponse => ({
    items: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.uuid(),
      seller: {
        id: faker.string.uuid(),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
        phone: faker.string.alpha({ length: { min: 10, max: 20 } }),
        city: faker.string.alpha({ length: { min: 10, max: 20 } }),
        country: faker.string.alpha({ length: { min: 10, max: 20 } }),
        created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
        updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
      },
      sales_period: faker.string.alpha({ length: { min: 10, max: 20 } }),
      goal: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      accumulate: faker.number.float({
        min: undefined,
        max: undefined,
        fractionDigits: 2,
      }),
      status: faker.string.alpha({ length: { min: 10, max: 20 } }),
      created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    })),
    total: faker.number.int({ min: undefined, max: undefined }),
    page: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    has_next: faker.datatype.boolean(),
    has_previous: faker.datatype.boolean(),
    ...overrideResponse,
  });

export const getCreateSalesPlanBffWebSalesPlansPostResponseMock = (
  overrideResponse: Partial<SalesPlanCreateResponse> = {},
): SalesPlanCreateResponse => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  message: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetSalesPlansBffWebSalesPlansGetResponseMock = (
  overrideResponse: Partial<PaginatedSalesPlansResponse> = {},
): PaginatedSalesPlansResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    seller: {
      id: faker.string.uuid(),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      phone: faker.string.alpha({ length: { min: 10, max: 20 } }),
      city: faker.string.alpha({ length: { min: 10, max: 20 } }),
      country: faker.string.alpha({ length: { min: 10, max: 20 } }),
      created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
      updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    },
    sales_period: faker.string.alpha({ length: { min: 10, max: 20 } }),
    goal: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    accumulate: faker.number.float({
      min: undefined,
      max: undefined,
      fractionDigits: 2,
    }),
    status: faker.string.alpha({ length: { min: 10, max: 20 } }),
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updated_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getCreateReportBffWebReportsPostResponseMock = (
  overrideResponse: Partial<ReportCreateResponse> = {},
): ReportCreateResponse => ({
  report_id: faker.string.uuid(),
  status: faker.helpers.arrayElement(Object.values(ReportStatus)),
  message: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getListReportsBffWebReportsGetResponseMock = (
  overrideResponse: Partial<PaginatedReportsResponse> = {},
): PaginatedReportsResponse => ({
  items: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.uuid(),
    report_type: faker.helpers.arrayElement(Object.values(ReportType)),
    status: faker.helpers.arrayElement(Object.values(ReportStatus)),
    start_date: `${faker.date.past().toISOString().split(".")[0]}Z`,
    end_date: `${faker.date.past().toISOString().split(".")[0]}Z`,
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    completed_at: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split(".")[0]}Z`,
        null,
      ]),
      undefined,
    ]),
    download_url: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      undefined,
    ]),
    error_message: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      undefined,
    ]),
  })),
  total: faker.number.int({ min: undefined, max: undefined }),
  page: faker.number.int({ min: undefined, max: undefined }),
  size: faker.number.int({ min: undefined, max: undefined }),
  has_next: faker.datatype.boolean(),
  has_previous: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetReportBffWebReportsReportIdGetResponseMock = (
  overrideResponse: Partial<ReportResponse> = {},
): ReportResponse => ({
  id: faker.string.uuid(),
  report_type: faker.helpers.arrayElement(Object.values(ReportType)),
  status: faker.helpers.arrayElement(Object.values(ReportStatus)),
  start_date: `${faker.date.past().toISOString().split(".")[0]}Z`,
  end_date: `${faker.date.past().toISOString().split(".")[0]}Z`,
  created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
  completed_at: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split(".")[0]}Z`,
      null,
    ]),
    undefined,
  ]),
  download_url: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  error_message: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getCreateProviderBffWebProviderPostMockHandler = (
  overrideResponse?:
    | ProviderCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<ProviderCreateResponse> | ProviderCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/provider",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateProviderBffWebProviderPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetProvidersBffWebProvidersGetMockHandler = (
  overrideResponse?:
    | PaginatedProvidersResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<PaginatedProvidersResponse> | PaginatedProvidersResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/providers",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProvidersBffWebProvidersGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateProductBffWebProductsPostMockHandler = (
  overrideResponse?:
    | BatchProductsResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<BatchProductsResponse> | BatchProductsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/products",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateProductBffWebProductsPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetProductsBffWebProductsGetMockHandler = (
  overrideResponse?:
    | PaginatedProductsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<PaginatedProductsResponse> | PaginatedProductsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/products",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetProductsBffWebProductsGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateProductsFromCsvBffWebProductsBatchPostMockHandler = (
  overrideResponse?:
    | BatchProductsResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<BatchProductsResponse> | BatchProductsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/products/batch",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateProductsFromCsvBffWebProductsBatchPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateWarehouseBffWebWarehousePostMockHandler = (
  overrideResponse?:
    | WarehouseCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<WarehouseCreateResponse> | WarehouseCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/warehouse",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateWarehouseBffWebWarehousePostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetWarehousesBffWebWarehousesGetMockHandler = (
  overrideResponse?:
    | PaginatedWarehousesResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<PaginatedWarehousesResponse> | PaginatedWarehousesResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/warehouses",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetWarehousesBffWebWarehousesGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateInventoryBffWebInventoryPostMockHandler = (
  overrideResponse?:
    | InventoryCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<InventoryCreateResponse> | InventoryCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/inventory",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateInventoryBffWebInventoryPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetInventoriesBffWebInventoriesGetMockHandler = (
  overrideResponse?:
    | PaginatedInventoriesResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) =>
        | Promise<PaginatedInventoriesResponse>
        | PaginatedInventoriesResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/inventories",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetInventoriesBffWebInventoriesGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateSellerBffWebSellersPostMockHandler = (
  overrideResponse?:
    | SellerCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<SellerCreateResponse> | SellerCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/sellers",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateSellerBffWebSellersPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetSellersBffWebSellersGetMockHandler = (
  overrideResponse?:
    | GetSellersBffWebSellersGet200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) =>
        | Promise<GetSellersBffWebSellersGet200>
        | GetSellersBffWebSellersGet200),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/sellers",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetSellersBffWebSellersGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetMockHandler =
  (
    overrideResponse?:
      | PaginatedSalesPlansResponse
      | ((
          info: Parameters<Parameters<typeof http.get>[1]>[0],
        ) =>
          | Promise<PaginatedSalesPlansResponse>
          | PaginatedSalesPlansResponse),
    options?: RequestHandlerOptions,
  ) => {
    return http.get(
      "*/bff/web/sellers/:sellerId/sales-plans",
      async (info) => {
        await delay(1000);

        return new HttpResponse(
          JSON.stringify(
            overrideResponse !== undefined
              ? typeof overrideResponse === "function"
                ? await overrideResponse(info)
                : overrideResponse
              : getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetResponseMock(),
          ),
          { status: 200, headers: { "Content-Type": "application/json" } },
        );
      },
      options,
    );
  };

export const getCreateSalesPlanBffWebSalesPlansPostMockHandler = (
  overrideResponse?:
    | SalesPlanCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<SalesPlanCreateResponse> | SalesPlanCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/sales-plans",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateSalesPlanBffWebSalesPlansPostResponseMock(),
        ),
        { status: 201, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetSalesPlansBffWebSalesPlansGetMockHandler = (
  overrideResponse?:
    | PaginatedSalesPlansResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<PaginatedSalesPlansResponse> | PaginatedSalesPlansResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/sales-plans",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetSalesPlansBffWebSalesPlansGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getCreateReportBffWebReportsPostMockHandler = (
  overrideResponse?:
    | ReportCreateResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<ReportCreateResponse> | ReportCreateResponse),
  options?: RequestHandlerOptions,
) => {
  return http.post(
    "*/bff/web/reports",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getCreateReportBffWebReportsPostResponseMock(),
        ),
        { status: 202, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getListReportsBffWebReportsGetMockHandler = (
  overrideResponse?:
    | PaginatedReportsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<PaginatedReportsResponse> | PaginatedReportsResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/reports",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getListReportsBffWebReportsGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};

export const getGetReportBffWebReportsReportIdGetMockHandler = (
  overrideResponse?:
    | ReportResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<ReportResponse> | ReportResponse),
  options?: RequestHandlerOptions,
) => {
  return http.get(
    "*/bff/web/reports/:reportId",
    async (info) => {
      await delay(1000);

      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGetReportBffWebReportsReportIdGetResponseMock(),
        ),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    },
    options,
  );
};
export const getWebMock = () => [
  getCreateProviderBffWebProviderPostMockHandler(),
  getGetProvidersBffWebProvidersGetMockHandler(),
  getCreateProductBffWebProductsPostMockHandler(),
  getGetProductsBffWebProductsGetMockHandler(),
  getCreateProductsFromCsvBffWebProductsBatchPostMockHandler(),
  getCreateWarehouseBffWebWarehousePostMockHandler(),
  getGetWarehousesBffWebWarehousesGetMockHandler(),
  getCreateInventoryBffWebInventoryPostMockHandler(),
  getGetInventoriesBffWebInventoriesGetMockHandler(),
  getCreateSellerBffWebSellersPostMockHandler(),
  getGetSellersBffWebSellersGetMockHandler(),
  getGetSellerSalesPlansBffWebSellersSellerIdSalesPlansGetMockHandler(),
  getCreateSalesPlanBffWebSalesPlansPostMockHandler(),
  getGetSalesPlansBffWebSalesPlansGetMockHandler(),
  getCreateReportBffWebReportsPostMockHandler(),
  getListReportsBffWebReportsGetMockHandler(),
  getGetReportBffWebReportsReportIdGetMockHandler(),
];
