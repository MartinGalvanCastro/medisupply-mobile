/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * BFF Service
 * Backend For Frontend service aggregating microservices
 * OpenAPI spec version: 1.0.0
 */
import { useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CheckAllServicesBffCheckAllGet200Item,
  CommonSchemasPaginatedInventoriesResponse,
  GetInventoriesBffInventoriesGetParams,
  HTTPValidationError,
  ReadRootBffGet200,
} from ".././models";

import { customInstance } from "../../client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Root endpoint returning service information.
 * @summary Read Root
 */
export const readRootBffGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ReadRootBffGet200>(
    { url: `/bff/`, method: "GET", signal },
    options,
  );
};

export const getReadRootBffGetQueryKey = () => {
  return [`/bff/`] as const;
};

export const getReadRootBffGetQueryOptions = <
  TData = Awaited<ReturnType<typeof readRootBffGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof readRootBffGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReadRootBffGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readRootBffGet>>> = ({
    signal,
  }) => readRootBffGet(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof readRootBffGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadRootBffGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof readRootBffGet>>
>;
export type ReadRootBffGetQueryError = unknown;

export function useReadRootBffGet<
  TData = Awaited<ReturnType<typeof readRootBffGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readRootBffGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRootBffGet>>,
          TError,
          Awaited<ReturnType<typeof readRootBffGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadRootBffGet<
  TData = Awaited<ReturnType<typeof readRootBffGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readRootBffGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRootBffGet>>,
          TError,
          Awaited<ReturnType<typeof readRootBffGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadRootBffGet<
  TData = Awaited<ReturnType<typeof readRootBffGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readRootBffGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Root
 */

export function useReadRootBffGet<
  TData = Awaited<ReturnType<typeof readRootBffGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readRootBffGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getReadRootBffGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Check health status of all microservices.

Returns:
    List of dictionaries with service name as key and health status as value.
    Example: [{"catalog": "healthy"}, {"order": "unhealthy"}, ...]
 * @summary Check All Services
 */
export const checkAllServicesBffCheckAllGet = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CheckAllServicesBffCheckAllGet200Item[]>(
    { url: `/bff/check-all`, method: "GET", signal },
    options,
  );
};

export const getCheckAllServicesBffCheckAllGetQueryKey = () => {
  return [`/bff/check-all`] as const;
};

export const getCheckAllServicesBffCheckAllGetQueryOptions = <
  TData = Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCheckAllServicesBffCheckAllGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>
  > = ({ signal }) => checkAllServicesBffCheckAllGet(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckAllServicesBffCheckAllGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>
>;
export type CheckAllServicesBffCheckAllGetQueryError = unknown;

export function useCheckAllServicesBffCheckAllGet<
  TData = Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
          TError,
          Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckAllServicesBffCheckAllGet<
  TData = Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
          TError,
          Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCheckAllServicesBffCheckAllGet<
  TData = Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Check All Services
 */

export function useCheckAllServicesBffCheckAllGet<
  TData = Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof checkAllServicesBffCheckAllGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCheckAllServicesBffCheckAllGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve inventories from the inventory microservice with optional filters.

**Authentication Required**: Only seller_users and client_users can access this endpoint.
Web users are NOT allowed.

Only ONE filter can be applied at a time (name OR sku OR category).

Each inventory item includes:
- Product details (SKU, name, price, category)
- Warehouse information (name, city, country)
- Stock levels (total, reserved, available quantities)
- Batch information (batch number, expiration date)

Args:
    limit: Maximum number of inventories to return (1-100)
    offset: Number of inventories to skip
    name: Optional product name filter
    sku: Optional product SKU filter
    category: Optional category filter
    user: Authenticated user (seller or client only)
    inventory: Inventory port for service communication

Returns:
    PaginatedInventoriesResponse with:
    - items: List of inventory records with full details
    - total: Total number of items matching the filter
    - page: Current page number
    - size: Number of items per page
    - has_next: Whether there are more pages
    - has_previous: Whether there are previous pages

Raises:
    HTTPException: 400 if more than one filter is provided
    HTTPException: 401 if authentication token is missing or invalid
    HTTPException: 403 if user is not a seller or client (e.g., web user)
 * @summary Get Inventories
 */
export const getInventoriesBffInventoriesGet = (
  params?: GetInventoriesBffInventoriesGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CommonSchemasPaginatedInventoriesResponse>(
    { url: `/bff/inventories`, method: "GET", params, signal },
    options,
  );
};

export const getGetInventoriesBffInventoriesGetQueryKey = (
  params?: GetInventoriesBffInventoriesGetParams,
) => {
  return [`/bff/inventories`, ...(params ? [params] : [])] as const;
};

export const getGetInventoriesBffInventoriesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetInventoriesBffInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInventoriesBffInventoriesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>
  > = ({ signal }) =>
    getInventoriesBffInventoriesGet(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInventoriesBffInventoriesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>
>;
export type GetInventoriesBffInventoriesGetQueryError =
  void | HTTPValidationError;

export function useGetInventoriesBffInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
  TError = void | HTTPValidationError,
>(
  params: undefined | GetInventoriesBffInventoriesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoriesBffInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetInventoriesBffInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetInventoriesBffInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetInventoriesBffInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Inventories
 */

export function useGetInventoriesBffInventoriesGet<
  TData = Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
  TError = void | HTTPValidationError,
>(
  params?: GetInventoriesBffInventoriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoriesBffInventoriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetInventoriesBffInventoriesGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
