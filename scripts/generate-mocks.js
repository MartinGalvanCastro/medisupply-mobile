#!/usr/bin/env node

/**
 * Mock Generator Script
 *
 * Automatically generates boilerplate mock handlers and data files
 * based on your OpenAPI-generated MSW files.
 *
 * Usage:
 *   node scripts/generate-mocks.js
 *   npm run mocks:generate
 *
 * What it does:
 * 1. Scans all .msw.ts files in src/api/generated/
 * 2. Extracts endpoint information (path, method, types)
 * 3. Generates handler boilerplate in src/api/mocks/handlers/
 * 4. Generates data boilerplate in src/api/mocks/data/
 * 5. Updates index exports
 */

const fs = require('fs');
const path = require('path');

// Configuration
const GENERATED_DIR = path.join(__dirname, '../src/api/generated');
const HANDLERS_DIR = path.join(__dirname, '../src/api/mocks/handlers');
const DATA_DIR = path.join(__dirname, '../src/api/mocks/data');

/**
 * Parse MSW file to extract endpoint information
 */
function parseMswFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const endpoints = [];

  // Regex to find http.method('pattern', ...) calls
  const handlerRegex = /http\.(get|post|put|patch|delete)\(['"`]([^'"`]+)['"`]/g;

  let match;
  while ((match = handlerRegex.exec(content)) !== null) {
    const [, method, pattern] = match;
    endpoints.push({
      method: method.toUpperCase(),
      pattern: pattern.replace(/\*/g, ''), // Remove wildcards
      handlerName: extractHandlerName(content, match.index),
    });
  }

  return endpoints;
}

/**
 * Extract handler function name from context
 */
function extractHandlerName(content, position) {
  // Look backwards for export const functionName
  const before = content.substring(0, position);
  const match = before.match(/export const (\w+)/g);
  return match ? match[match.length - 1].replace('export const ', '') : 'unknownHandler';
}

/**
 * Group endpoints by domain
 */
function groupEndpointsByDomain(endpoints) {
  const groups = {};

  endpoints.forEach(endpoint => {
    // Extract domain from path (e.g., /auth/login -> auth, /bff/client-app/orders -> clientApp)
    let domain = 'general';

    if (endpoint.pattern.includes('/auth/')) domain = 'authentication';
    else if (endpoint.pattern.includes('/bff/client-app/')) domain = 'clientApp';
    else if (endpoint.pattern.includes('/bff/sellers-app/')) domain = 'sellersApp';
    else if (endpoint.pattern.includes('/bff/web/')) domain = 'web';

    if (!groups[domain]) groups[domain] = [];
    groups[domain].push(endpoint);
  });

  return groups;
}

/**
 * Generate handler file boilerplate
 */
function generateHandlerFile(domain, endpoints) {
  const domainTitle = domain.charAt(0).toUpperCase() + domain.slice(1);
  const dataImportName = `mock${domainTitle}Data`;

  return `/**
 * Custom ${domainTitle} Mock Handlers
 *
 * Generated by: npm run mocks:generate
 * TODO: Add realistic mock data and logic
 */

import { http, HttpResponse, delay } from 'msw';
import { getMockDelay, mockConfig } from '../config';
import { ${dataImportName} } from '../data/${domain}.data';
// TODO: Import types from generated models
// import type { YourRequestType, YourResponseType } from '@/api/generated/models';

export const ${domain}Handlers = [
${endpoints.map(endpoint => `
  // ${endpoint.method} ${endpoint.pattern}
  http.${endpoint.method.toLowerCase()}('*${endpoint.pattern}', async ({ request }) => {
    await delay(getMockDelay());

    if (mockConfig.scenarios === 'error') {
      return HttpResponse.json(
        { detail: 'Mock error response' },
        { status: 500 }
      );
    }

    if (mockConfig.logging) {
      console.log('[MSW] ${endpoint.method} ${endpoint.pattern}');
    }

    // TODO: Add your mock response logic here
    return HttpResponse.json(${dataImportName}.default, { status: 200 });
  }),
`).join('\n')}
];
`;
}

/**
 * Generate data file boilerplate
 */
function generateDataFile(domain) {
  const domainTitle = domain.charAt(0).toUpperCase() + domain.slice(1);

  return `/**
 * Centralized ${domainTitle} Mock Data
 *
 * Generated by: npm run mocks:generate
 * TODO: Add realistic mock data based on your business requirements
 */

// TODO: Import types from generated models
// import type { YourDataType } from '@/api/generated/models';

export const mock${domainTitle}Data = {
  // Default response
  default: {
    message: 'Default ${domain} mock response',
    // TODO: Add realistic fields
  },

  // Example: Success scenario
  success: {
    // TODO: Add success scenario data
  },

  // Example: Empty scenario
  empty: {
    items: [],
    total: 0,
  },

  // Example: Error scenario
  error: {
    detail: '${domainTitle} error occurred',
    code: 'MOCK_ERROR',
  },
};

// Example: List of entities
export const mock${domainTitle}List = [
  {
    id: '${domain}-001',
    // TODO: Add realistic fields
  },
];
`;
}

/**
 * Update index.ts exports
 */
function updateIndexFile(directory, fileNames, exportType = 'handlers') {
  const indexPath = path.join(directory, 'index.ts');

  const imports = fileNames.map(name =>
    `import { ${name}${exportType === 'handlers' ? 'Handlers' : 'Data'} } from './${name}.${exportType === 'handlers' ? 'handlers' : 'data'}';`
  ).join('\n');

  const exports = fileNames.map(name =>
    `  ...${name}${exportType === 'handlers' ? 'Handlers' : 'Data'},`
  ).join('\n');

  const content = `/**
 * Export all ${exportType}
 *
 * Auto-generated by: npm run mocks:generate
 */

${imports}

export const ${exportType} = [
${exports}
];
`;

  fs.writeFileSync(indexPath, content, 'utf-8');
  console.log(`‚úÖ Updated ${indexPath}`);
}

/**
 * Main execution
 */
function main() {
  console.log('üöÄ Starting mock generation...\n');

  // Ensure directories exist
  if (!fs.existsSync(HANDLERS_DIR)) fs.mkdirSync(HANDLERS_DIR, { recursive: true });
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

  // Find all MSW files
  const mswFiles = [];
  function findMswFiles(dir) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        findMswFiles(fullPath);
      } else if (file.endsWith('.msw.ts')) {
        mswFiles.push(fullPath);
      }
    });
  }

  findMswFiles(GENERATED_DIR);
  console.log(`üìÅ Found ${mswFiles.length} MSW files\n`);

  // Parse all endpoints
  let allEndpoints = [];
  mswFiles.forEach(file => {
    console.log(`üìñ Parsing ${path.basename(file)}...`);
    const endpoints = parseMswFile(file);
    allEndpoints = allEndpoints.concat(endpoints);
    console.log(`   Found ${endpoints.length} endpoints`);
  });

  console.log(`\nüìä Total endpoints: ${allEndpoints.length}\n`);

  // Group by domain
  const grouped = groupEndpointsByDomain(allEndpoints);
  console.log('üóÇÔ∏è  Grouped by domain:');
  Object.keys(grouped).forEach(domain => {
    console.log(`   - ${domain}: ${grouped[domain].length} endpoints`);
  });

  console.log('\n‚úçÔ∏è  Generating files...\n');

  const generatedDomains = [];

  // Generate handler and data files for each domain
  Object.keys(grouped).forEach(domain => {
    const handlerPath = path.join(HANDLERS_DIR, `${domain}.handlers.ts`);
    const dataPath = path.join(DATA_DIR, `${domain}.data.ts`);

    // Only generate if file doesn't exist (don't overwrite existing customizations)
    if (!fs.existsSync(handlerPath)) {
      const handlerContent = generateHandlerFile(domain, grouped[domain]);
      fs.writeFileSync(handlerPath, handlerContent, 'utf-8');
      console.log(`‚úÖ Generated ${handlerPath}`);
    } else {
      console.log(`‚è≠Ô∏è  Skipped ${handlerPath} (already exists)`);
    }

    if (!fs.existsSync(dataPath)) {
      const dataContent = generateDataFile(domain);
      fs.writeFileSync(dataPath, dataContent, 'utf-8');
      console.log(`‚úÖ Generated ${dataPath}`);
    } else {
      console.log(`‚è≠Ô∏è  Skipped ${dataPath} (already exists)`);
    }

    generatedDomains.push(domain);
  });

  // Update index exports
  console.log('\nüì¶ Updating index exports...\n');
  updateIndexFile(HANDLERS_DIR, generatedDomains, 'handlers');
  updateIndexFile(DATA_DIR, generatedDomains, 'data');

  console.log('\n‚ú® Mock generation complete!\n');
  console.log('Next steps:');
  console.log('1. Review generated files in src/api/mocks/');
  console.log('2. Add realistic mock data in src/api/mocks/data/');
  console.log('3. Customize handler logic in src/api/mocks/handlers/');
  console.log('4. Import proper TypeScript types from generated models');
  console.log('\nHappy mocking! üé≠\n');
}

// Run if called directly
if (require.main === module) {
  try {
    main();
  } catch (error) {
    console.error('‚ùå Error generating mocks:', error);
    process.exit(1);
  }
}

module.exports = { main };
